// Copyright (c) Abstract Machines

// SPDX-License-Identifier: Apache-2.0

// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/absmach/supermq-contrib/twins"
	mock "github.com/stretchr/testify/mock"
)

// NewTwinRepository creates a new instance of TwinRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTwinRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *TwinRepository {
	mock := &TwinRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TwinRepository is an autogenerated mock type for the TwinRepository type
type TwinRepository struct {
	mock.Mock
}

type TwinRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *TwinRepository) EXPECT() *TwinRepository_Expecter {
	return &TwinRepository_Expecter{mock: &_m.Mock}
}

// Remove provides a mock function for the type TwinRepository
func (_mock *TwinRepository) Remove(ctx context.Context, twinID string) error {
	ret := _mock.Called(ctx, twinID)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, twinID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TwinRepository_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type TwinRepository_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
//   - twinID string
func (_e *TwinRepository_Expecter) Remove(ctx interface{}, twinID interface{}) *TwinRepository_Remove_Call {
	return &TwinRepository_Remove_Call{Call: _e.mock.On("Remove", ctx, twinID)}
}

func (_c *TwinRepository_Remove_Call) Run(run func(ctx context.Context, twinID string)) *TwinRepository_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TwinRepository_Remove_Call) Return(err error) *TwinRepository_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TwinRepository_Remove_Call) RunAndReturn(run func(ctx context.Context, twinID string) error) *TwinRepository_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveAll provides a mock function for the type TwinRepository
func (_mock *TwinRepository) RetrieveAll(ctx context.Context, owner string, offset uint64, limit uint64, name string, metadata twins.Metadata) (twins.Page, error) {
	ret := _mock.Called(ctx, owner, offset, limit, name, metadata)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveAll")
	}

	var r0 twins.Page
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, uint64, string, twins.Metadata) (twins.Page, error)); ok {
		return returnFunc(ctx, owner, offset, limit, name, metadata)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, uint64, string, twins.Metadata) twins.Page); ok {
		r0 = returnFunc(ctx, owner, offset, limit, name, metadata)
	} else {
		r0 = ret.Get(0).(twins.Page)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uint64, uint64, string, twins.Metadata) error); ok {
		r1 = returnFunc(ctx, owner, offset, limit, name, metadata)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TwinRepository_RetrieveAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveAll'
type TwinRepository_RetrieveAll_Call struct {
	*mock.Call
}

// RetrieveAll is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - offset uint64
//   - limit uint64
//   - name string
//   - metadata twins.Metadata
func (_e *TwinRepository_Expecter) RetrieveAll(ctx interface{}, owner interface{}, offset interface{}, limit interface{}, name interface{}, metadata interface{}) *TwinRepository_RetrieveAll_Call {
	return &TwinRepository_RetrieveAll_Call{Call: _e.mock.On("RetrieveAll", ctx, owner, offset, limit, name, metadata)}
}

func (_c *TwinRepository_RetrieveAll_Call) Run(run func(ctx context.Context, owner string, offset uint64, limit uint64, name string, metadata twins.Metadata)) *TwinRepository_RetrieveAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 uint64
		if args[3] != nil {
			arg3 = args[3].(uint64)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 twins.Metadata
		if args[5] != nil {
			arg5 = args[5].(twins.Metadata)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *TwinRepository_RetrieveAll_Call) Return(page twins.Page, err error) *TwinRepository_RetrieveAll_Call {
	_c.Call.Return(page, err)
	return _c
}

func (_c *TwinRepository_RetrieveAll_Call) RunAndReturn(run func(ctx context.Context, owner string, offset uint64, limit uint64, name string, metadata twins.Metadata) (twins.Page, error)) *TwinRepository_RetrieveAll_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveByAttribute provides a mock function for the type TwinRepository
func (_mock *TwinRepository) RetrieveByAttribute(ctx context.Context, channel string, subtopic string) ([]string, error) {
	ret := _mock.Called(ctx, channel, subtopic)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveByAttribute")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) ([]string, error)); ok {
		return returnFunc(ctx, channel, subtopic)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) []string); ok {
		r0 = returnFunc(ctx, channel, subtopic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, channel, subtopic)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TwinRepository_RetrieveByAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveByAttribute'
type TwinRepository_RetrieveByAttribute_Call struct {
	*mock.Call
}

// RetrieveByAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - channel string
//   - subtopic string
func (_e *TwinRepository_Expecter) RetrieveByAttribute(ctx interface{}, channel interface{}, subtopic interface{}) *TwinRepository_RetrieveByAttribute_Call {
	return &TwinRepository_RetrieveByAttribute_Call{Call: _e.mock.On("RetrieveByAttribute", ctx, channel, subtopic)}
}

func (_c *TwinRepository_RetrieveByAttribute_Call) Run(run func(ctx context.Context, channel string, subtopic string)) *TwinRepository_RetrieveByAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TwinRepository_RetrieveByAttribute_Call) Return(strings []string, err error) *TwinRepository_RetrieveByAttribute_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *TwinRepository_RetrieveByAttribute_Call) RunAndReturn(run func(ctx context.Context, channel string, subtopic string) ([]string, error)) *TwinRepository_RetrieveByAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveByID provides a mock function for the type TwinRepository
func (_mock *TwinRepository) RetrieveByID(ctx context.Context, twinID string) (twins.Twin, error) {
	ret := _mock.Called(ctx, twinID)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveByID")
	}

	var r0 twins.Twin
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (twins.Twin, error)); ok {
		return returnFunc(ctx, twinID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) twins.Twin); ok {
		r0 = returnFunc(ctx, twinID)
	} else {
		r0 = ret.Get(0).(twins.Twin)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, twinID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TwinRepository_RetrieveByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveByID'
type TwinRepository_RetrieveByID_Call struct {
	*mock.Call
}

// RetrieveByID is a helper method to define mock.On call
//   - ctx context.Context
//   - twinID string
func (_e *TwinRepository_Expecter) RetrieveByID(ctx interface{}, twinID interface{}) *TwinRepository_RetrieveByID_Call {
	return &TwinRepository_RetrieveByID_Call{Call: _e.mock.On("RetrieveByID", ctx, twinID)}
}

func (_c *TwinRepository_RetrieveByID_Call) Run(run func(ctx context.Context, twinID string)) *TwinRepository_RetrieveByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TwinRepository_RetrieveByID_Call) Return(twin twins.Twin, err error) *TwinRepository_RetrieveByID_Call {
	_c.Call.Return(twin, err)
	return _c
}

func (_c *TwinRepository_RetrieveByID_Call) RunAndReturn(run func(ctx context.Context, twinID string) (twins.Twin, error)) *TwinRepository_RetrieveByID_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type TwinRepository
func (_mock *TwinRepository) Save(ctx context.Context, twin twins.Twin) (string, error) {
	ret := _mock.Called(ctx, twin)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, twins.Twin) (string, error)); ok {
		return returnFunc(ctx, twin)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, twins.Twin) string); ok {
		r0 = returnFunc(ctx, twin)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, twins.Twin) error); ok {
		r1 = returnFunc(ctx, twin)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TwinRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type TwinRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - twin twins.Twin
func (_e *TwinRepository_Expecter) Save(ctx interface{}, twin interface{}) *TwinRepository_Save_Call {
	return &TwinRepository_Save_Call{Call: _e.mock.On("Save", ctx, twin)}
}

func (_c *TwinRepository_Save_Call) Run(run func(ctx context.Context, twin twins.Twin)) *TwinRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 twins.Twin
		if args[1] != nil {
			arg1 = args[1].(twins.Twin)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TwinRepository_Save_Call) Return(s string, err error) *TwinRepository_Save_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *TwinRepository_Save_Call) RunAndReturn(run func(ctx context.Context, twin twins.Twin) (string, error)) *TwinRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type TwinRepository
func (_mock *TwinRepository) Update(ctx context.Context, twin twins.Twin) error {
	ret := _mock.Called(ctx, twin)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, twins.Twin) error); ok {
		r0 = returnFunc(ctx, twin)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TwinRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type TwinRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - twin twins.Twin
func (_e *TwinRepository_Expecter) Update(ctx interface{}, twin interface{}) *TwinRepository_Update_Call {
	return &TwinRepository_Update_Call{Call: _e.mock.On("Update", ctx, twin)}
}

func (_c *TwinRepository_Update_Call) Run(run func(ctx context.Context, twin twins.Twin)) *TwinRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 twins.Twin
		if args[1] != nil {
			arg1 = args[1].(twins.Twin)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TwinRepository_Update_Call) Return(err error) *TwinRepository_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TwinRepository_Update_Call) RunAndReturn(run func(ctx context.Context, twin twins.Twin) error) *TwinRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}
